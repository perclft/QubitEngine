# Variables
CXX = g++
GO = go
PROTOC = protoc
PROTO_DIR = api/proto
CPP_OUT_DIR = backend/src/generated
GO_OUT_DIR = cli/internal/generated

# Docker Image Names
ENGINE_IMAGE = qubit-engine:latest
CLI_IMAGE = qctl:latest

.PHONY: all clean proto build-cpp build-go docker-build deploy

all: proto build-cpp build-go

# 1. GENERATE CODE FROM PROTOBUFS
# Generates both C++ and Go code from the single .proto source
proto:
	@echo "Generating Protobufs..."
	@mkdir -p $(CPP_OUT_DIR)
	@mkdir -p $(GO_OUT_DIR)
	$(PROTOC) -I $(PROTO_DIR) --grpc_out=$(CPP_OUT_DIR) --cpp_out=$(CPP_OUT_DIR) \
		--plugin=protoc-gen-grpc=`which grpc_cpp_plugin` $(PROTO_DIR)/quantum.proto
	$(PROTOC) -I $(PROTO_DIR) --go_out=$(GO_OUT_DIR) --go-grpc_out=$(GO_OUT_DIR) \
		$(PROTO_DIR)/quantum.proto

# 2. BUILD C++ ENGINE (Using CMake)
build-cpp: proto
	@echo "Building C++ Engine..."
	@mkdir -p backend/build
	cd backend/build && cmake .. && make

# 3. BUILD GO CLI
build-go: proto
	@echo "Building Go CLI..."
	cd cli && $(GO) build -o ../bin/qctl ./cmd/qctl

# 4. CONTAINERIZATION
docker-build:
	@echo "Building Docker Images..."
	docker build -t $(ENGINE_IMAGE) -f deploy/docker/Dockerfile.engine .
	docker build -t $(CLI_IMAGE) -f deploy/docker/Dockerfile.cli .

# 5. DEPLOY TO KUBERNETES (Assuming kubectl is configured for your Rancher cluster)
deploy:
	@echo "Deploying to Kubernetes..."
	kubectl apply -f deploy/k8s/namespace.yaml
	kubectl apply -f deploy/k8s/
