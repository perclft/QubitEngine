syntax = "proto3";

package qubit_engine;

// Standard options for Go (used in your original file)
option go_package = "github.com/perclft/QubitEngine/cli/internal/generated";

// Standard options for C++ (often included for generated headers)
option cc_enable_arenas = true;
option java_multiple_files = true;
option java_package = "com.perclft.qubitengine";

// ------------------------------------------------------------------
// Service Definition
// ------------------------------------------------------------------

service QuantumCompute {
  // Synchronous run for small to medium circuits.
  rpc RunCircuit (CircuitRequest) returns (StateResponse) {}
  
  // Streaming method for large or interactive circuits.
  // Sends a stream of gates and receives a stream of FULL STATE VECTORS.
  rpc StreamGates (stream GateOperation) returns (stream StateResponse) {}

  // Visualization method for Web (Server-Side Streaming only).
  // gRPC-Web does not support bidirectional streaming.
  // This executes a circuit and streams back the state after EACH step.
  rpc VisualizeCircuit (CircuitRequest) returns (stream StateResponse) {}
}

// ------------------------------------------------------------------
// Messages (Data Structures)
// ------------------------------------------------------------------

message CircuitRequest {
  int32 num_qubits = 1;
  repeated GateOperation operations = 2;
  // Probability of a depolarizing error occurring per step (0.0 - 1.0)
  double noise_probability = 3;
}

message GateOperation {
  enum GateType {
    HADAMARD = 0;
    PAULI_X = 1;
    CNOT = 2;
    MEASURE = 3;
    // New Gates
    TOFFOLI = 4;
    PHASE_S = 5; // S Gate (Z90)
    PHASE_T = 6; // T Gate (Z45)
    ROTATION_Y = 7;
    ROTATION_Z = 8;
  }
  GateType type = 1;
  uint32 target_qubit = 2;
  uint32 control_qubit = 3;
  // Optional: Register to store the classical result (useful for complex circuits)
  uint32 classical_register = 4;
  
  // For Rotations
  double angle = 5; // Rotation angle in radians
  
  // For Toffoli (3rd qubit)
  uint32 second_control_qubit = 6;
}

message StateResponse {
  message ComplexNumber {
    // Note: Using 'double' is standard for quantum state vectors.
    double real = 1;
    double imag = 2;
  }
  // The full state vector of size 2^num_qubits
  repeated ComplexNumber state_vector = 1;

  // Return measured classical bits (e.g., Qubit 0 -> 1)
  map<uint32, bool> classical_results = 2;

  // Identity of the server (Hostname/Pod ID) that processed this step
  string server_id = 3;
}

message Measurement {
  uint32 qubit_index = 1;
  bool result = 2;
  double probability = 3; // Probability of the measured result
}
