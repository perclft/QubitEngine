// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "crypto/crypto.proto" (package "qubit_engine.crypto", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { QuantumCrypto } from "./crypto";
import type { EavesdropResult } from "./crypto";
import type { EavesdropRequest } from "./crypto";
import type { DecryptedMessage } from "./crypto";
import type { DecryptRequest } from "./crypto";
import type { EncryptedMessage } from "./crypto";
import type { EncryptRequest } from "./crypto";
import type { QuantumKey } from "./crypto";
import type { KeyRequest } from "./crypto";
import type { BB84Key } from "./crypto";
import type { ReconcileRequest } from "./crypto";
import type { BB84BobState } from "./crypto";
import type { BB84BobRequest } from "./crypto";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { BB84AliceState } from "./crypto";
import type { BB84AliceRequest } from "./crypto";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
// ------------------------------------------------------------------
// Quantum Cryptography Service
// BB84 QKD Protocol and quantum-safe key distribution
// ------------------------------------------------------------------

/**
 * @generated from protobuf service qubit_engine.crypto.QuantumCrypto
 */
export interface IQuantumCryptoClient {
    /**
     * Initialize BB84 key exchange as Alice (sender)
     *
     * @generated from protobuf rpc: StartBB84Alice
     */
    startBB84Alice(input: BB84AliceRequest, options?: RpcOptions): UnaryCall<BB84AliceRequest, BB84AliceState>;
    /**
     * Initialize BB84 key exchange as Bob (receiver)
     *
     * @generated from protobuf rpc: StartBB84Bob
     */
    startBB84Bob(input: BB84BobRequest, options?: RpcOptions): UnaryCall<BB84BobRequest, BB84BobState>;
    /**
     * Complete BB84 by reconciling bases
     *
     * @generated from protobuf rpc: ReconcileBB84
     */
    reconcileBB84(input: ReconcileRequest, options?: RpcOptions): UnaryCall<ReconcileRequest, BB84Key>;
    /**
     * Generate quantum random key
     *
     * @generated from protobuf rpc: GenerateQuantumKey
     */
    generateQuantumKey(input: KeyRequest, options?: RpcOptions): UnaryCall<KeyRequest, QuantumKey>;
    /**
     * Encrypt message with quantum key
     *
     * @generated from protobuf rpc: QuantumEncrypt
     */
    quantumEncrypt(input: EncryptRequest, options?: RpcOptions): UnaryCall<EncryptRequest, EncryptedMessage>;
    /**
     * Decrypt message with quantum key
     *
     * @generated from protobuf rpc: QuantumDecrypt
     */
    quantumDecrypt(input: DecryptRequest, options?: RpcOptions): UnaryCall<DecryptRequest, DecryptedMessage>;
    /**
     * Detect eavesdropping in BB84
     *
     * @generated from protobuf rpc: DetectEavesdropping
     */
    detectEavesdropping(input: EavesdropRequest, options?: RpcOptions): UnaryCall<EavesdropRequest, EavesdropResult>;
}
// ------------------------------------------------------------------
// Quantum Cryptography Service
// BB84 QKD Protocol and quantum-safe key distribution
// ------------------------------------------------------------------

/**
 * @generated from protobuf service qubit_engine.crypto.QuantumCrypto
 */
export class QuantumCryptoClient implements IQuantumCryptoClient, ServiceInfo {
    typeName = QuantumCrypto.typeName;
    methods = QuantumCrypto.methods;
    options = QuantumCrypto.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Initialize BB84 key exchange as Alice (sender)
     *
     * @generated from protobuf rpc: StartBB84Alice
     */
    startBB84Alice(input: BB84AliceRequest, options?: RpcOptions): UnaryCall<BB84AliceRequest, BB84AliceState> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<BB84AliceRequest, BB84AliceState>("unary", this._transport, method, opt, input);
    }
    /**
     * Initialize BB84 key exchange as Bob (receiver)
     *
     * @generated from protobuf rpc: StartBB84Bob
     */
    startBB84Bob(input: BB84BobRequest, options?: RpcOptions): UnaryCall<BB84BobRequest, BB84BobState> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<BB84BobRequest, BB84BobState>("unary", this._transport, method, opt, input);
    }
    /**
     * Complete BB84 by reconciling bases
     *
     * @generated from protobuf rpc: ReconcileBB84
     */
    reconcileBB84(input: ReconcileRequest, options?: RpcOptions): UnaryCall<ReconcileRequest, BB84Key> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReconcileRequest, BB84Key>("unary", this._transport, method, opt, input);
    }
    /**
     * Generate quantum random key
     *
     * @generated from protobuf rpc: GenerateQuantumKey
     */
    generateQuantumKey(input: KeyRequest, options?: RpcOptions): UnaryCall<KeyRequest, QuantumKey> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<KeyRequest, QuantumKey>("unary", this._transport, method, opt, input);
    }
    /**
     * Encrypt message with quantum key
     *
     * @generated from protobuf rpc: QuantumEncrypt
     */
    quantumEncrypt(input: EncryptRequest, options?: RpcOptions): UnaryCall<EncryptRequest, EncryptedMessage> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<EncryptRequest, EncryptedMessage>("unary", this._transport, method, opt, input);
    }
    /**
     * Decrypt message with quantum key
     *
     * @generated from protobuf rpc: QuantumDecrypt
     */
    quantumDecrypt(input: DecryptRequest, options?: RpcOptions): UnaryCall<DecryptRequest, DecryptedMessage> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<DecryptRequest, DecryptedMessage>("unary", this._transport, method, opt, input);
    }
    /**
     * Detect eavesdropping in BB84
     *
     * @generated from protobuf rpc: DetectEavesdropping
     */
    detectEavesdropping(input: EavesdropRequest, options?: RpcOptions): UnaryCall<EavesdropRequest, EavesdropResult> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<EavesdropRequest, EavesdropResult>("unary", this._transport, method, opt, input);
    }
}
