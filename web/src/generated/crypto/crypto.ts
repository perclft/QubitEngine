// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "crypto/crypto.proto" (package "qubit_engine.crypto", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message qubit_engine.crypto.BB84AliceRequest
 */
export interface BB84AliceRequest {
    /**
     * @generated from protobuf field: int32 num_bits = 1
     */
    numBits: number; // Number of qubits to send
    /**
     * @generated from protobuf field: string session_id = 2
     */
    sessionId: string;
    /**
     * @generated from protobuf field: double eavesdrop_probability = 3
     */
    eavesdropProbability: number; // Simulation: Probability of eavesdropping
}
/**
 * @generated from protobuf message qubit_engine.crypto.BB84AliceState
 */
export interface BB84AliceState {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: repeated int32 bits = 2
     */
    bits: number[]; // Alice's random bits
    /**
     * @generated from protobuf field: repeated qubit_engine.crypto.Basis bases = 3
     */
    bases: Basis[]; // Alice's random basis choices
    /**
     * @generated from protobuf field: bytes quantum_states = 4
     */
    quantumStates: Uint8Array; // Encoded quantum states (simulated)
}
/**
 * @generated from protobuf message qubit_engine.crypto.BB84BobRequest
 */
export interface BB84BobRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: bytes quantum_states = 2
     */
    quantumStates: Uint8Array; // Received from Alice
}
/**
 * @generated from protobuf message qubit_engine.crypto.BB84BobState
 */
export interface BB84BobState {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: repeated qubit_engine.crypto.Basis bases = 2
     */
    bases: Basis[]; // Bob's random basis choices
    /**
     * @generated from protobuf field: repeated int32 measurements = 3
     */
    measurements: number[]; // Bob's measurement results
}
/**
 * @generated from protobuf message qubit_engine.crypto.ReconcileRequest
 */
export interface ReconcileRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: repeated qubit_engine.crypto.Basis alice_bases = 2
     */
    aliceBases: Basis[];
    /**
     * @generated from protobuf field: repeated qubit_engine.crypto.Basis bob_bases = 3
     */
    bobBases: Basis[];
    /**
     * @generated from protobuf field: repeated int32 alice_bits = 4
     */
    aliceBits: number[];
    /**
     * @generated from protobuf field: repeated int32 bob_measurements = 5
     */
    bobMeasurements: number[];
}
/**
 * @generated from protobuf message qubit_engine.crypto.BB84Key
 */
export interface BB84Key {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: bytes shared_key = 2
     */
    sharedKey: Uint8Array; // The resulting shared secret
    /**
     * @generated from protobuf field: int32 original_bits = 3
     */
    originalBits: number; // How many bits we started with
    /**
     * @generated from protobuf field: int32 sifted_bits = 4
     */
    siftedBits: number; // How many bits survived sifting
    /**
     * @generated from protobuf field: double error_rate = 5
     */
    errorRate: number; // Estimated error rate
    /**
     * @generated from protobuf field: bool secure = 6
     */
    secure: boolean; // True if error rate is acceptable
}
// ------------------------------------------------------------------
// Quantum Key Generation
// ------------------------------------------------------------------

/**
 * @generated from protobuf message qubit_engine.crypto.KeyRequest
 */
export interface KeyRequest {
    /**
     * @generated from protobuf field: int32 key_length_bits = 1
     */
    keyLengthBits: number;
    /**
     * @generated from protobuf field: string algorithm = 2
     */
    algorithm: string; // "qrng", "bb84", "e91"
}
/**
 * @generated from protobuf message qubit_engine.crypto.QuantumKey
 */
export interface QuantumKey {
    /**
     * @generated from protobuf field: bytes key = 1
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: string algorithm = 2
     */
    algorithm: string;
    /**
     * @generated from protobuf field: int64 generated_at = 3
     */
    generatedAt: bigint;
    /**
     * @generated from protobuf field: string entropy_source = 4
     */
    entropySource: string;
}
// ------------------------------------------------------------------
// Quantum Encryption
// ------------------------------------------------------------------

/**
 * @generated from protobuf message qubit_engine.crypto.EncryptRequest
 */
export interface EncryptRequest {
    /**
     * @generated from protobuf field: bytes plaintext = 1
     */
    plaintext: Uint8Array;
    /**
     * @generated from protobuf field: bytes key = 2
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: string algorithm = 3
     */
    algorithm: string; // "otp", "aes-qrng"
}
/**
 * @generated from protobuf message qubit_engine.crypto.EncryptedMessage
 */
export interface EncryptedMessage {
    /**
     * @generated from protobuf field: bytes ciphertext = 1
     */
    ciphertext: Uint8Array;
    /**
     * @generated from protobuf field: bytes nonce = 2
     */
    nonce: Uint8Array;
    /**
     * @generated from protobuf field: string algorithm = 3
     */
    algorithm: string;
}
/**
 * @generated from protobuf message qubit_engine.crypto.DecryptRequest
 */
export interface DecryptRequest {
    /**
     * @generated from protobuf field: bytes ciphertext = 1
     */
    ciphertext: Uint8Array;
    /**
     * @generated from protobuf field: bytes key = 2
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes nonce = 3
     */
    nonce: Uint8Array;
    /**
     * @generated from protobuf field: string algorithm = 4
     */
    algorithm: string;
}
/**
 * @generated from protobuf message qubit_engine.crypto.DecryptedMessage
 */
export interface DecryptedMessage {
    /**
     * @generated from protobuf field: bytes plaintext = 1
     */
    plaintext: Uint8Array;
    /**
     * @generated from protobuf field: bool valid = 2
     */
    valid: boolean;
}
// ------------------------------------------------------------------
// Eavesdropping Detection
// ------------------------------------------------------------------

/**
 * @generated from protobuf message qubit_engine.crypto.EavesdropRequest
 */
export interface EavesdropRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: repeated int32 alice_check_bits = 2
     */
    aliceCheckBits: number[];
    /**
     * @generated from protobuf field: repeated int32 bob_check_bits = 3
     */
    bobCheckBits: number[];
    /**
     * @generated from protobuf field: double eavesdrop_probability = 4
     */
    eavesdropProbability: number; // Probability that Eve measures a qubit (0.0 - 1.0)
}
/**
 * @generated from protobuf message qubit_engine.crypto.EavesdropResult
 */
export interface EavesdropResult {
    /**
     * @generated from protobuf field: double error_rate = 1
     */
    errorRate: number;
    /**
     * @generated from protobuf field: bool eavesdropper_detected = 2
     */
    eavesdropperDetected: boolean;
    /**
     * @generated from protobuf field: string recommendation = 3
     */
    recommendation: string; // "proceed", "abort", "retry"
}
// ------------------------------------------------------------------
// BB84 Protocol
// ------------------------------------------------------------------

/**
 * @generated from protobuf enum qubit_engine.crypto.Basis
 */
export enum Basis {
    /**
     * |0⟩, |1⟩ (Z basis)
     *
     * @generated from protobuf enum value: BASIS_RECTILINEAR = 0;
     */
    RECTILINEAR = 0,
    /**
     * |+⟩, |−⟩ (X basis)
     *
     * @generated from protobuf enum value: BASIS_DIAGONAL = 1;
     */
    DIAGONAL = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class BB84AliceRequest$Type extends MessageType<BB84AliceRequest> {
    constructor() {
        super("qubit_engine.crypto.BB84AliceRequest", [
            { no: 1, name: "num_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "eavesdrop_probability", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<BB84AliceRequest>): BB84AliceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numBits = 0;
        message.sessionId = "";
        message.eavesdropProbability = 0;
        if (value !== undefined)
            reflectionMergePartial<BB84AliceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BB84AliceRequest): BB84AliceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 num_bits */ 1:
                    message.numBits = reader.int32();
                    break;
                case /* string session_id */ 2:
                    message.sessionId = reader.string();
                    break;
                case /* double eavesdrop_probability */ 3:
                    message.eavesdropProbability = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BB84AliceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 num_bits = 1; */
        if (message.numBits !== 0)
            writer.tag(1, WireType.Varint).int32(message.numBits);
        /* string session_id = 2; */
        if (message.sessionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionId);
        /* double eavesdrop_probability = 3; */
        if (message.eavesdropProbability !== 0)
            writer.tag(3, WireType.Bit64).double(message.eavesdropProbability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.BB84AliceRequest
 */
export const BB84AliceRequest = new BB84AliceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BB84AliceState$Type extends MessageType<BB84AliceState> {
    constructor() {
        super("qubit_engine.crypto.BB84AliceState", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bits", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "bases", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["qubit_engine.crypto.Basis", Basis, "BASIS_"] },
            { no: 4, name: "quantum_states", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BB84AliceState>): BB84AliceState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.bits = [];
        message.bases = [];
        message.quantumStates = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<BB84AliceState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BB84AliceState): BB84AliceState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* repeated int32 bits */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bits.push(reader.int32());
                    else
                        message.bits.push(reader.int32());
                    break;
                case /* repeated qubit_engine.crypto.Basis bases */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bases.push(reader.int32());
                    else
                        message.bases.push(reader.int32());
                    break;
                case /* bytes quantum_states */ 4:
                    message.quantumStates = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BB84AliceState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* repeated int32 bits = 2; */
        if (message.bits.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bits.length; i++)
                writer.int32(message.bits[i]);
            writer.join();
        }
        /* repeated qubit_engine.crypto.Basis bases = 3; */
        if (message.bases.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bases.length; i++)
                writer.int32(message.bases[i]);
            writer.join();
        }
        /* bytes quantum_states = 4; */
        if (message.quantumStates.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.quantumStates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.BB84AliceState
 */
export const BB84AliceState = new BB84AliceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BB84BobRequest$Type extends MessageType<BB84BobRequest> {
    constructor() {
        super("qubit_engine.crypto.BB84BobRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantum_states", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BB84BobRequest>): BB84BobRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.quantumStates = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<BB84BobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BB84BobRequest): BB84BobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* bytes quantum_states */ 2:
                    message.quantumStates = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BB84BobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* bytes quantum_states = 2; */
        if (message.quantumStates.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.quantumStates);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.BB84BobRequest
 */
export const BB84BobRequest = new BB84BobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BB84BobState$Type extends MessageType<BB84BobState> {
    constructor() {
        super("qubit_engine.crypto.BB84BobState", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bases", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["qubit_engine.crypto.Basis", Basis, "BASIS_"] },
            { no: 3, name: "measurements", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BB84BobState>): BB84BobState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.bases = [];
        message.measurements = [];
        if (value !== undefined)
            reflectionMergePartial<BB84BobState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BB84BobState): BB84BobState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* repeated qubit_engine.crypto.Basis bases */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bases.push(reader.int32());
                    else
                        message.bases.push(reader.int32());
                    break;
                case /* repeated int32 measurements */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.measurements.push(reader.int32());
                    else
                        message.measurements.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BB84BobState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* repeated qubit_engine.crypto.Basis bases = 2; */
        if (message.bases.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bases.length; i++)
                writer.int32(message.bases[i]);
            writer.join();
        }
        /* repeated int32 measurements = 3; */
        if (message.measurements.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.measurements.length; i++)
                writer.int32(message.measurements[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.BB84BobState
 */
export const BB84BobState = new BB84BobState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReconcileRequest$Type extends MessageType<ReconcileRequest> {
    constructor() {
        super("qubit_engine.crypto.ReconcileRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "alice_bases", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["qubit_engine.crypto.Basis", Basis, "BASIS_"] },
            { no: 3, name: "bob_bases", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["qubit_engine.crypto.Basis", Basis, "BASIS_"] },
            { no: 4, name: "alice_bits", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "bob_measurements", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReconcileRequest>): ReconcileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.aliceBases = [];
        message.bobBases = [];
        message.aliceBits = [];
        message.bobMeasurements = [];
        if (value !== undefined)
            reflectionMergePartial<ReconcileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReconcileRequest): ReconcileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* repeated qubit_engine.crypto.Basis alice_bases */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.aliceBases.push(reader.int32());
                    else
                        message.aliceBases.push(reader.int32());
                    break;
                case /* repeated qubit_engine.crypto.Basis bob_bases */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bobBases.push(reader.int32());
                    else
                        message.bobBases.push(reader.int32());
                    break;
                case /* repeated int32 alice_bits */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.aliceBits.push(reader.int32());
                    else
                        message.aliceBits.push(reader.int32());
                    break;
                case /* repeated int32 bob_measurements */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bobMeasurements.push(reader.int32());
                    else
                        message.bobMeasurements.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReconcileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* repeated qubit_engine.crypto.Basis alice_bases = 2; */
        if (message.aliceBases.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.aliceBases.length; i++)
                writer.int32(message.aliceBases[i]);
            writer.join();
        }
        /* repeated qubit_engine.crypto.Basis bob_bases = 3; */
        if (message.bobBases.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bobBases.length; i++)
                writer.int32(message.bobBases[i]);
            writer.join();
        }
        /* repeated int32 alice_bits = 4; */
        if (message.aliceBits.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.aliceBits.length; i++)
                writer.int32(message.aliceBits[i]);
            writer.join();
        }
        /* repeated int32 bob_measurements = 5; */
        if (message.bobMeasurements.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bobMeasurements.length; i++)
                writer.int32(message.bobMeasurements[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.ReconcileRequest
 */
export const ReconcileRequest = new ReconcileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BB84Key$Type extends MessageType<BB84Key> {
    constructor() {
        super("qubit_engine.crypto.BB84Key", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shared_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "original_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sifted_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "error_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "secure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BB84Key>): BB84Key {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.sharedKey = new Uint8Array(0);
        message.originalBits = 0;
        message.siftedBits = 0;
        message.errorRate = 0;
        message.secure = false;
        if (value !== undefined)
            reflectionMergePartial<BB84Key>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BB84Key): BB84Key {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* bytes shared_key */ 2:
                    message.sharedKey = reader.bytes();
                    break;
                case /* int32 original_bits */ 3:
                    message.originalBits = reader.int32();
                    break;
                case /* int32 sifted_bits */ 4:
                    message.siftedBits = reader.int32();
                    break;
                case /* double error_rate */ 5:
                    message.errorRate = reader.double();
                    break;
                case /* bool secure */ 6:
                    message.secure = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BB84Key, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* bytes shared_key = 2; */
        if (message.sharedKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.sharedKey);
        /* int32 original_bits = 3; */
        if (message.originalBits !== 0)
            writer.tag(3, WireType.Varint).int32(message.originalBits);
        /* int32 sifted_bits = 4; */
        if (message.siftedBits !== 0)
            writer.tag(4, WireType.Varint).int32(message.siftedBits);
        /* double error_rate = 5; */
        if (message.errorRate !== 0)
            writer.tag(5, WireType.Bit64).double(message.errorRate);
        /* bool secure = 6; */
        if (message.secure !== false)
            writer.tag(6, WireType.Varint).bool(message.secure);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.BB84Key
 */
export const BB84Key = new BB84Key$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyRequest$Type extends MessageType<KeyRequest> {
    constructor() {
        super("qubit_engine.crypto.KeyRequest", [
            { no: 1, name: "key_length_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KeyRequest>): KeyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyLengthBits = 0;
        message.algorithm = "";
        if (value !== undefined)
            reflectionMergePartial<KeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyRequest): KeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 key_length_bits */ 1:
                    message.keyLengthBits = reader.int32();
                    break;
                case /* string algorithm */ 2:
                    message.algorithm = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 key_length_bits = 1; */
        if (message.keyLengthBits !== 0)
            writer.tag(1, WireType.Varint).int32(message.keyLengthBits);
        /* string algorithm = 2; */
        if (message.algorithm !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.algorithm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.KeyRequest
 */
export const KeyRequest = new KeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuantumKey$Type extends MessageType<QuantumKey> {
    constructor() {
        super("qubit_engine.crypto.QuantumKey", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "generated_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "entropy_source", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuantumKey>): QuantumKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = new Uint8Array(0);
        message.algorithm = "";
        message.generatedAt = 0n;
        message.entropySource = "";
        if (value !== undefined)
            reflectionMergePartial<QuantumKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuantumKey): QuantumKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* string algorithm */ 2:
                    message.algorithm = reader.string();
                    break;
                case /* int64 generated_at */ 3:
                    message.generatedAt = reader.int64().toBigInt();
                    break;
                case /* string entropy_source */ 4:
                    message.entropySource = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuantumKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* string algorithm = 2; */
        if (message.algorithm !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.algorithm);
        /* int64 generated_at = 3; */
        if (message.generatedAt !== 0n)
            writer.tag(3, WireType.Varint).int64(message.generatedAt);
        /* string entropy_source = 4; */
        if (message.entropySource !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.entropySource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.QuantumKey
 */
export const QuantumKey = new QuantumKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptRequest$Type extends MessageType<EncryptRequest> {
    constructor() {
        super("qubit_engine.crypto.EncryptRequest", [
            { no: 1, name: "plaintext", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EncryptRequest>): EncryptRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.plaintext = new Uint8Array(0);
        message.key = new Uint8Array(0);
        message.algorithm = "";
        if (value !== undefined)
            reflectionMergePartial<EncryptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptRequest): EncryptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes plaintext */ 1:
                    message.plaintext = reader.bytes();
                    break;
                case /* bytes key */ 2:
                    message.key = reader.bytes();
                    break;
                case /* string algorithm */ 3:
                    message.algorithm = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes plaintext = 1; */
        if (message.plaintext.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.plaintext);
        /* bytes key = 2; */
        if (message.key.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.key);
        /* string algorithm = 3; */
        if (message.algorithm !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.algorithm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.EncryptRequest
 */
export const EncryptRequest = new EncryptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptedMessage$Type extends MessageType<EncryptedMessage> {
    constructor() {
        super("qubit_engine.crypto.EncryptedMessage", [
            { no: 1, name: "ciphertext", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EncryptedMessage>): EncryptedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ciphertext = new Uint8Array(0);
        message.nonce = new Uint8Array(0);
        message.algorithm = "";
        if (value !== undefined)
            reflectionMergePartial<EncryptedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptedMessage): EncryptedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ciphertext */ 1:
                    message.ciphertext = reader.bytes();
                    break;
                case /* bytes nonce */ 2:
                    message.nonce = reader.bytes();
                    break;
                case /* string algorithm */ 3:
                    message.algorithm = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ciphertext = 1; */
        if (message.ciphertext.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ciphertext);
        /* bytes nonce = 2; */
        if (message.nonce.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.nonce);
        /* string algorithm = 3; */
        if (message.algorithm !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.algorithm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.EncryptedMessage
 */
export const EncryptedMessage = new EncryptedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptRequest$Type extends MessageType<DecryptRequest> {
    constructor() {
        super("qubit_engine.crypto.DecryptRequest", [
            { no: 1, name: "ciphertext", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DecryptRequest>): DecryptRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ciphertext = new Uint8Array(0);
        message.key = new Uint8Array(0);
        message.nonce = new Uint8Array(0);
        message.algorithm = "";
        if (value !== undefined)
            reflectionMergePartial<DecryptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptRequest): DecryptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ciphertext */ 1:
                    message.ciphertext = reader.bytes();
                    break;
                case /* bytes key */ 2:
                    message.key = reader.bytes();
                    break;
                case /* bytes nonce */ 3:
                    message.nonce = reader.bytes();
                    break;
                case /* string algorithm */ 4:
                    message.algorithm = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ciphertext = 1; */
        if (message.ciphertext.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ciphertext);
        /* bytes key = 2; */
        if (message.key.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.key);
        /* bytes nonce = 3; */
        if (message.nonce.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.nonce);
        /* string algorithm = 4; */
        if (message.algorithm !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.algorithm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.DecryptRequest
 */
export const DecryptRequest = new DecryptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptedMessage$Type extends MessageType<DecryptedMessage> {
    constructor() {
        super("qubit_engine.crypto.DecryptedMessage", [
            { no: 1, name: "plaintext", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DecryptedMessage>): DecryptedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.plaintext = new Uint8Array(0);
        message.valid = false;
        if (value !== undefined)
            reflectionMergePartial<DecryptedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptedMessage): DecryptedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes plaintext */ 1:
                    message.plaintext = reader.bytes();
                    break;
                case /* bool valid */ 2:
                    message.valid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes plaintext = 1; */
        if (message.plaintext.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.plaintext);
        /* bool valid = 2; */
        if (message.valid !== false)
            writer.tag(2, WireType.Varint).bool(message.valid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.DecryptedMessage
 */
export const DecryptedMessage = new DecryptedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EavesdropRequest$Type extends MessageType<EavesdropRequest> {
    constructor() {
        super("qubit_engine.crypto.EavesdropRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "alice_check_bits", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "bob_check_bits", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "eavesdrop_probability", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<EavesdropRequest>): EavesdropRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.aliceCheckBits = [];
        message.bobCheckBits = [];
        message.eavesdropProbability = 0;
        if (value !== undefined)
            reflectionMergePartial<EavesdropRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EavesdropRequest): EavesdropRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* repeated int32 alice_check_bits */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.aliceCheckBits.push(reader.int32());
                    else
                        message.aliceCheckBits.push(reader.int32());
                    break;
                case /* repeated int32 bob_check_bits */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bobCheckBits.push(reader.int32());
                    else
                        message.bobCheckBits.push(reader.int32());
                    break;
                case /* double eavesdrop_probability */ 4:
                    message.eavesdropProbability = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EavesdropRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* repeated int32 alice_check_bits = 2; */
        if (message.aliceCheckBits.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.aliceCheckBits.length; i++)
                writer.int32(message.aliceCheckBits[i]);
            writer.join();
        }
        /* repeated int32 bob_check_bits = 3; */
        if (message.bobCheckBits.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bobCheckBits.length; i++)
                writer.int32(message.bobCheckBits[i]);
            writer.join();
        }
        /* double eavesdrop_probability = 4; */
        if (message.eavesdropProbability !== 0)
            writer.tag(4, WireType.Bit64).double(message.eavesdropProbability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.EavesdropRequest
 */
export const EavesdropRequest = new EavesdropRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EavesdropResult$Type extends MessageType<EavesdropResult> {
    constructor() {
        super("qubit_engine.crypto.EavesdropResult", [
            { no: 1, name: "error_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "eavesdropper_detected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "recommendation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EavesdropResult>): EavesdropResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorRate = 0;
        message.eavesdropperDetected = false;
        message.recommendation = "";
        if (value !== undefined)
            reflectionMergePartial<EavesdropResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EavesdropResult): EavesdropResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double error_rate */ 1:
                    message.errorRate = reader.double();
                    break;
                case /* bool eavesdropper_detected */ 2:
                    message.eavesdropperDetected = reader.bool();
                    break;
                case /* string recommendation */ 3:
                    message.recommendation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EavesdropResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double error_rate = 1; */
        if (message.errorRate !== 0)
            writer.tag(1, WireType.Bit64).double(message.errorRate);
        /* bool eavesdropper_detected = 2; */
        if (message.eavesdropperDetected !== false)
            writer.tag(2, WireType.Varint).bool(message.eavesdropperDetected);
        /* string recommendation = 3; */
        if (message.recommendation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.recommendation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.crypto.EavesdropResult
 */
export const EavesdropResult = new EavesdropResult$Type();
/**
 * @generated ServiceType for protobuf service qubit_engine.crypto.QuantumCrypto
 */
export const QuantumCrypto = new ServiceType("qubit_engine.crypto.QuantumCrypto", [
    { name: "StartBB84Alice", options: {}, I: BB84AliceRequest, O: BB84AliceState },
    { name: "StartBB84Bob", options: {}, I: BB84BobRequest, O: BB84BobState },
    { name: "ReconcileBB84", options: {}, I: ReconcileRequest, O: BB84Key },
    { name: "GenerateQuantumKey", options: {}, I: KeyRequest, O: QuantumKey },
    { name: "QuantumEncrypt", options: {}, I: EncryptRequest, O: EncryptedMessage },
    { name: "QuantumDecrypt", options: {}, I: DecryptRequest, O: DecryptedMessage },
    { name: "DetectEavesdropping", options: {}, I: EavesdropRequest, O: EavesdropResult }
]);
