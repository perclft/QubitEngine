// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "quantum.proto" (package "qubit_engine", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// ------------------------------------------------------------------
// Messages (Data Structures)
// ------------------------------------------------------------------

/**
 * @generated from protobuf message qubit_engine.CircuitRequest
 */
export interface CircuitRequest {
    /**
     * @generated from protobuf field: int32 num_qubits = 1
     */
    numQubits: number;
    /**
     * @generated from protobuf field: repeated qubit_engine.GateOperation operations = 2
     */
    operations: GateOperation[];
    /**
     * Probability of a depolarizing error occurring per step (0.0 - 1.0)
     *
     * @generated from protobuf field: double noise_probability = 3
     */
    noiseProbability: number;
}
/**
 * @generated from protobuf message qubit_engine.GateOperation
 */
export interface GateOperation {
    /**
     * @generated from protobuf field: qubit_engine.GateOperation.GateType type = 1
     */
    type: GateOperation_GateType;
    /**
     * @generated from protobuf field: uint32 target_qubit = 2
     */
    targetQubit: number;
    /**
     * @generated from protobuf field: uint32 control_qubit = 3
     */
    controlQubit: number;
    /**
     * Optional: Register to store the classical result (useful for complex circuits)
     *
     * @generated from protobuf field: uint32 classical_register = 4
     */
    classicalRegister: number;
    /**
     * For Rotations
     *
     * @generated from protobuf field: double angle = 5
     */
    angle: number; // Rotation angle in radians
    /**
     * For Toffoli (3rd qubit)
     *
     * @generated from protobuf field: uint32 second_control_qubit = 6
     */
    secondControlQubit: number;
}
/**
 * @generated from protobuf enum qubit_engine.GateOperation.GateType
 */
export enum GateOperation_GateType {
    /**
     * @generated from protobuf enum value: HADAMARD = 0;
     */
    HADAMARD = 0,
    /**
     * @generated from protobuf enum value: PAULI_X = 1;
     */
    PAULI_X = 1,
    /**
     * @generated from protobuf enum value: CNOT = 2;
     */
    CNOT = 2,
    /**
     * @generated from protobuf enum value: MEASURE = 3;
     */
    MEASURE = 3,
    /**
     * New Gates
     *
     * @generated from protobuf enum value: TOFFOLI = 4;
     */
    TOFFOLI = 4,
    /**
     * S Gate (Z90)
     *
     * @generated from protobuf enum value: PHASE_S = 5;
     */
    PHASE_S = 5,
    /**
     * T Gate (Z45)
     *
     * @generated from protobuf enum value: PHASE_T = 6;
     */
    PHASE_T = 6,
    /**
     * @generated from protobuf enum value: ROTATION_Y = 7;
     */
    ROTATION_Y = 7,
    /**
     * @generated from protobuf enum value: ROTATION_Z = 8;
     */
    ROTATION_Z = 8
}
/**
 * @generated from protobuf message qubit_engine.StateResponse
 */
export interface StateResponse {
    /**
     * The full state vector of size 2^num_qubits
     *
     * @generated from protobuf field: repeated qubit_engine.StateResponse.ComplexNumber state_vector = 1
     */
    stateVector: StateResponse_ComplexNumber[];
    /**
     * Return measured classical bits (e.g., Qubit 0 -> 1)
     *
     * @generated from protobuf field: map<uint32, bool> classical_results = 2
     */
    classicalResults: {
        [key: number]: boolean;
    };
    /**
     * Identity of the server (Hostname/Pod ID) that processed this step
     *
     * @generated from protobuf field: string server_id = 3
     */
    serverId: string;
}
/**
 * @generated from protobuf message qubit_engine.StateResponse.ComplexNumber
 */
export interface StateResponse_ComplexNumber {
    /**
     * Note: Using 'double' is standard for quantum state vectors.
     *
     * @generated from protobuf field: double real = 1
     */
    real: number;
    /**
     * @generated from protobuf field: double imag = 2
     */
    imag: number;
}
/**
 * @generated from protobuf message qubit_engine.Measurement
 */
export interface Measurement {
    /**
     * @generated from protobuf field: uint32 qubit_index = 1
     */
    qubitIndex: number;
    /**
     * @generated from protobuf field: bool result = 2
     */
    result: boolean;
    /**
     * @generated from protobuf field: double probability = 3
     */
    probability: number; // Probability of the measured result
}
// @generated message type with reflection information, may provide speed optimized methods
class CircuitRequest$Type extends MessageType<CircuitRequest> {
    constructor() {
        super("qubit_engine.CircuitRequest", [
            { no: 1, name: "num_qubits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "operations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GateOperation },
            { no: 3, name: "noise_probability", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<CircuitRequest>): CircuitRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numQubits = 0;
        message.operations = [];
        message.noiseProbability = 0;
        if (value !== undefined)
            reflectionMergePartial<CircuitRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CircuitRequest): CircuitRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 num_qubits */ 1:
                    message.numQubits = reader.int32();
                    break;
                case /* repeated qubit_engine.GateOperation operations */ 2:
                    message.operations.push(GateOperation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* double noise_probability */ 3:
                    message.noiseProbability = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CircuitRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 num_qubits = 1; */
        if (message.numQubits !== 0)
            writer.tag(1, WireType.Varint).int32(message.numQubits);
        /* repeated qubit_engine.GateOperation operations = 2; */
        for (let i = 0; i < message.operations.length; i++)
            GateOperation.internalBinaryWrite(message.operations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double noise_probability = 3; */
        if (message.noiseProbability !== 0)
            writer.tag(3, WireType.Bit64).double(message.noiseProbability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.CircuitRequest
 */
export const CircuitRequest = new CircuitRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GateOperation$Type extends MessageType<GateOperation> {
    constructor() {
        super("qubit_engine.GateOperation", [
            { no: 1, name: "type", kind: "enum", T: () => ["qubit_engine.GateOperation.GateType", GateOperation_GateType] },
            { no: 2, name: "target_qubit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "control_qubit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "classical_register", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "angle", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "second_control_qubit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GateOperation>): GateOperation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.targetQubit = 0;
        message.controlQubit = 0;
        message.classicalRegister = 0;
        message.angle = 0;
        message.secondControlQubit = 0;
        if (value !== undefined)
            reflectionMergePartial<GateOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GateOperation): GateOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* qubit_engine.GateOperation.GateType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* uint32 target_qubit */ 2:
                    message.targetQubit = reader.uint32();
                    break;
                case /* uint32 control_qubit */ 3:
                    message.controlQubit = reader.uint32();
                    break;
                case /* uint32 classical_register */ 4:
                    message.classicalRegister = reader.uint32();
                    break;
                case /* double angle */ 5:
                    message.angle = reader.double();
                    break;
                case /* uint32 second_control_qubit */ 6:
                    message.secondControlQubit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GateOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* qubit_engine.GateOperation.GateType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* uint32 target_qubit = 2; */
        if (message.targetQubit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.targetQubit);
        /* uint32 control_qubit = 3; */
        if (message.controlQubit !== 0)
            writer.tag(3, WireType.Varint).uint32(message.controlQubit);
        /* uint32 classical_register = 4; */
        if (message.classicalRegister !== 0)
            writer.tag(4, WireType.Varint).uint32(message.classicalRegister);
        /* double angle = 5; */
        if (message.angle !== 0)
            writer.tag(5, WireType.Bit64).double(message.angle);
        /* uint32 second_control_qubit = 6; */
        if (message.secondControlQubit !== 0)
            writer.tag(6, WireType.Varint).uint32(message.secondControlQubit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.GateOperation
 */
export const GateOperation = new GateOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StateResponse$Type extends MessageType<StateResponse> {
    constructor() {
        super("qubit_engine.StateResponse", [
            { no: 1, name: "state_vector", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StateResponse_ComplexNumber },
            { no: 2, name: "classical_results", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 3, name: "server_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StateResponse>): StateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stateVector = [];
        message.classicalResults = {};
        message.serverId = "";
        if (value !== undefined)
            reflectionMergePartial<StateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StateResponse): StateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated qubit_engine.StateResponse.ComplexNumber state_vector */ 1:
                    message.stateVector.push(StateResponse_ComplexNumber.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint32, bool> classical_results */ 2:
                    this.binaryReadMap2(message.classicalResults, reader, options);
                    break;
                case /* string server_id */ 3:
                    message.serverId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: StateResponse["classicalResults"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof StateResponse["classicalResults"] | undefined, val: StateResponse["classicalResults"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for qubit_engine.StateResponse.classical_results");
            }
        }
        map[key ?? 0] = val ?? false;
    }
    internalBinaryWrite(message: StateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated qubit_engine.StateResponse.ComplexNumber state_vector = 1; */
        for (let i = 0; i < message.stateVector.length; i++)
            StateResponse_ComplexNumber.internalBinaryWrite(message.stateVector[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, bool> classical_results = 2; */
        for (let k of globalThis.Object.keys(message.classicalResults))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).bool(message.classicalResults[k as any]).join();
        /* string server_id = 3; */
        if (message.serverId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.StateResponse
 */
export const StateResponse = new StateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StateResponse_ComplexNumber$Type extends MessageType<StateResponse_ComplexNumber> {
    constructor() {
        super("qubit_engine.StateResponse.ComplexNumber", [
            { no: 1, name: "real", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "imag", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<StateResponse_ComplexNumber>): StateResponse_ComplexNumber {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.real = 0;
        message.imag = 0;
        if (value !== undefined)
            reflectionMergePartial<StateResponse_ComplexNumber>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StateResponse_ComplexNumber): StateResponse_ComplexNumber {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double real */ 1:
                    message.real = reader.double();
                    break;
                case /* double imag */ 2:
                    message.imag = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StateResponse_ComplexNumber, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double real = 1; */
        if (message.real !== 0)
            writer.tag(1, WireType.Bit64).double(message.real);
        /* double imag = 2; */
        if (message.imag !== 0)
            writer.tag(2, WireType.Bit64).double(message.imag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.StateResponse.ComplexNumber
 */
export const StateResponse_ComplexNumber = new StateResponse_ComplexNumber$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Measurement$Type extends MessageType<Measurement> {
    constructor() {
        super("qubit_engine.Measurement", [
            { no: 1, name: "qubit_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "result", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "probability", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Measurement>): Measurement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.qubitIndex = 0;
        message.result = false;
        message.probability = 0;
        if (value !== undefined)
            reflectionMergePartial<Measurement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Measurement): Measurement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 qubit_index */ 1:
                    message.qubitIndex = reader.uint32();
                    break;
                case /* bool result */ 2:
                    message.result = reader.bool();
                    break;
                case /* double probability */ 3:
                    message.probability = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Measurement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 qubit_index = 1; */
        if (message.qubitIndex !== 0)
            writer.tag(1, WireType.Varint).uint32(message.qubitIndex);
        /* bool result = 2; */
        if (message.result !== false)
            writer.tag(2, WireType.Varint).bool(message.result);
        /* double probability = 3; */
        if (message.probability !== 0)
            writer.tag(3, WireType.Bit64).double(message.probability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message qubit_engine.Measurement
 */
export const Measurement = new Measurement$Type();
/**
 * @generated ServiceType for protobuf service qubit_engine.QuantumCompute
 */
export const QuantumCompute = new ServiceType("qubit_engine.QuantumCompute", [
    { name: "RunCircuit", options: {}, I: CircuitRequest, O: StateResponse },
    { name: "StreamGates", serverStreaming: true, clientStreaming: true, options: {}, I: GateOperation, O: StateResponse },
    { name: "VisualizeCircuit", serverStreaming: true, options: {}, I: CircuitRequest, O: StateResponse }
]);
