// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.0
// source: crypto/crypto.proto

package crypto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Basis int32

const (
	Basis_BASIS_RECTILINEAR Basis = 0 // |0⟩, |1⟩ (Z basis)
	Basis_BASIS_DIAGONAL    Basis = 1 // |+⟩, |−⟩ (X basis)
)

// Enum value maps for Basis.
var (
	Basis_name = map[int32]string{
		0: "BASIS_RECTILINEAR",
		1: "BASIS_DIAGONAL",
	}
	Basis_value = map[string]int32{
		"BASIS_RECTILINEAR": 0,
		"BASIS_DIAGONAL":    1,
	}
)

func (x Basis) Enum() *Basis {
	p := new(Basis)
	*p = x
	return p
}

func (x Basis) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Basis) Descriptor() protoreflect.EnumDescriptor {
	return file_crypto_crypto_proto_enumTypes[0].Descriptor()
}

func (Basis) Type() protoreflect.EnumType {
	return &file_crypto_crypto_proto_enumTypes[0]
}

func (x Basis) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Basis.Descriptor instead.
func (Basis) EnumDescriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{0}
}

type BB84AliceRequest struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	NumBits              int32                  `protobuf:"varint,1,opt,name=num_bits,json=numBits,proto3" json:"num_bits,omitempty"` // Number of qubits to send
	SessionId            string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	EavesdropProbability float64                `protobuf:"fixed64,3,opt,name=eavesdrop_probability,json=eavesdropProbability,proto3" json:"eavesdrop_probability,omitempty"` // Simulation: Probability of eavesdropping
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *BB84AliceRequest) Reset() {
	*x = BB84AliceRequest{}
	mi := &file_crypto_crypto_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BB84AliceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BB84AliceRequest) ProtoMessage() {}

func (x *BB84AliceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BB84AliceRequest.ProtoReflect.Descriptor instead.
func (*BB84AliceRequest) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{0}
}

func (x *BB84AliceRequest) GetNumBits() int32 {
	if x != nil {
		return x.NumBits
	}
	return 0
}

func (x *BB84AliceRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *BB84AliceRequest) GetEavesdropProbability() float64 {
	if x != nil {
		return x.EavesdropProbability
	}
	return 0
}

type BB84AliceState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Bits          []int32                `protobuf:"varint,2,rep,packed,name=bits,proto3" json:"bits,omitempty"`                                  // Alice's random bits
	Bases         []Basis                `protobuf:"varint,3,rep,packed,name=bases,proto3,enum=qubit_engine.crypto.Basis" json:"bases,omitempty"` // Alice's random basis choices
	QuantumStates []byte                 `protobuf:"bytes,4,opt,name=quantum_states,json=quantumStates,proto3" json:"quantum_states,omitempty"`   // Encoded quantum states (simulated)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BB84AliceState) Reset() {
	*x = BB84AliceState{}
	mi := &file_crypto_crypto_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BB84AliceState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BB84AliceState) ProtoMessage() {}

func (x *BB84AliceState) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BB84AliceState.ProtoReflect.Descriptor instead.
func (*BB84AliceState) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{1}
}

func (x *BB84AliceState) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *BB84AliceState) GetBits() []int32 {
	if x != nil {
		return x.Bits
	}
	return nil
}

func (x *BB84AliceState) GetBases() []Basis {
	if x != nil {
		return x.Bases
	}
	return nil
}

func (x *BB84AliceState) GetQuantumStates() []byte {
	if x != nil {
		return x.QuantumStates
	}
	return nil
}

type BB84BobRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	QuantumStates []byte                 `protobuf:"bytes,2,opt,name=quantum_states,json=quantumStates,proto3" json:"quantum_states,omitempty"` // Received from Alice
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BB84BobRequest) Reset() {
	*x = BB84BobRequest{}
	mi := &file_crypto_crypto_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BB84BobRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BB84BobRequest) ProtoMessage() {}

func (x *BB84BobRequest) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BB84BobRequest.ProtoReflect.Descriptor instead.
func (*BB84BobRequest) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{2}
}

func (x *BB84BobRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *BB84BobRequest) GetQuantumStates() []byte {
	if x != nil {
		return x.QuantumStates
	}
	return nil
}

type BB84BobState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Bases         []Basis                `protobuf:"varint,2,rep,packed,name=bases,proto3,enum=qubit_engine.crypto.Basis" json:"bases,omitempty"` // Bob's random basis choices
	Measurements  []int32                `protobuf:"varint,3,rep,packed,name=measurements,proto3" json:"measurements,omitempty"`                  // Bob's measurement results
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BB84BobState) Reset() {
	*x = BB84BobState{}
	mi := &file_crypto_crypto_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BB84BobState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BB84BobState) ProtoMessage() {}

func (x *BB84BobState) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BB84BobState.ProtoReflect.Descriptor instead.
func (*BB84BobState) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{3}
}

func (x *BB84BobState) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *BB84BobState) GetBases() []Basis {
	if x != nil {
		return x.Bases
	}
	return nil
}

func (x *BB84BobState) GetMeasurements() []int32 {
	if x != nil {
		return x.Measurements
	}
	return nil
}

type ReconcileRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	SessionId       string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	AliceBases      []Basis                `protobuf:"varint,2,rep,packed,name=alice_bases,json=aliceBases,proto3,enum=qubit_engine.crypto.Basis" json:"alice_bases,omitempty"`
	BobBases        []Basis                `protobuf:"varint,3,rep,packed,name=bob_bases,json=bobBases,proto3,enum=qubit_engine.crypto.Basis" json:"bob_bases,omitempty"`
	AliceBits       []int32                `protobuf:"varint,4,rep,packed,name=alice_bits,json=aliceBits,proto3" json:"alice_bits,omitempty"`
	BobMeasurements []int32                `protobuf:"varint,5,rep,packed,name=bob_measurements,json=bobMeasurements,proto3" json:"bob_measurements,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ReconcileRequest) Reset() {
	*x = ReconcileRequest{}
	mi := &file_crypto_crypto_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReconcileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReconcileRequest) ProtoMessage() {}

func (x *ReconcileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReconcileRequest.ProtoReflect.Descriptor instead.
func (*ReconcileRequest) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{4}
}

func (x *ReconcileRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ReconcileRequest) GetAliceBases() []Basis {
	if x != nil {
		return x.AliceBases
	}
	return nil
}

func (x *ReconcileRequest) GetBobBases() []Basis {
	if x != nil {
		return x.BobBases
	}
	return nil
}

func (x *ReconcileRequest) GetAliceBits() []int32 {
	if x != nil {
		return x.AliceBits
	}
	return nil
}

func (x *ReconcileRequest) GetBobMeasurements() []int32 {
	if x != nil {
		return x.BobMeasurements
	}
	return nil
}

type BB84Key struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	SharedKey     []byte                 `protobuf:"bytes,2,opt,name=shared_key,json=sharedKey,proto3" json:"shared_key,omitempty"`           // The resulting shared secret
	OriginalBits  int32                  `protobuf:"varint,3,opt,name=original_bits,json=originalBits,proto3" json:"original_bits,omitempty"` // How many bits we started with
	SiftedBits    int32                  `protobuf:"varint,4,opt,name=sifted_bits,json=siftedBits,proto3" json:"sifted_bits,omitempty"`       // How many bits survived sifting
	ErrorRate     float64                `protobuf:"fixed64,5,opt,name=error_rate,json=errorRate,proto3" json:"error_rate,omitempty"`         // Estimated error rate
	Secure        bool                   `protobuf:"varint,6,opt,name=secure,proto3" json:"secure,omitempty"`                                 // True if error rate is acceptable
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BB84Key) Reset() {
	*x = BB84Key{}
	mi := &file_crypto_crypto_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BB84Key) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BB84Key) ProtoMessage() {}

func (x *BB84Key) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BB84Key.ProtoReflect.Descriptor instead.
func (*BB84Key) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{5}
}

func (x *BB84Key) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *BB84Key) GetSharedKey() []byte {
	if x != nil {
		return x.SharedKey
	}
	return nil
}

func (x *BB84Key) GetOriginalBits() int32 {
	if x != nil {
		return x.OriginalBits
	}
	return 0
}

func (x *BB84Key) GetSiftedBits() int32 {
	if x != nil {
		return x.SiftedBits
	}
	return 0
}

func (x *BB84Key) GetErrorRate() float64 {
	if x != nil {
		return x.ErrorRate
	}
	return 0
}

func (x *BB84Key) GetSecure() bool {
	if x != nil {
		return x.Secure
	}
	return false
}

type KeyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	KeyLengthBits int32                  `protobuf:"varint,1,opt,name=key_length_bits,json=keyLengthBits,proto3" json:"key_length_bits,omitempty"`
	Algorithm     string                 `protobuf:"bytes,2,opt,name=algorithm,proto3" json:"algorithm,omitempty"` // "qrng", "bb84", "e91"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyRequest) Reset() {
	*x = KeyRequest{}
	mi := &file_crypto_crypto_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyRequest) ProtoMessage() {}

func (x *KeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyRequest.ProtoReflect.Descriptor instead.
func (*KeyRequest) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{6}
}

func (x *KeyRequest) GetKeyLengthBits() int32 {
	if x != nil {
		return x.KeyLengthBits
	}
	return 0
}

func (x *KeyRequest) GetAlgorithm() string {
	if x != nil {
		return x.Algorithm
	}
	return ""
}

type QuantumKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           []byte                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Algorithm     string                 `protobuf:"bytes,2,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	GeneratedAt   int64                  `protobuf:"varint,3,opt,name=generated_at,json=generatedAt,proto3" json:"generated_at,omitempty"`
	EntropySource string                 `protobuf:"bytes,4,opt,name=entropy_source,json=entropySource,proto3" json:"entropy_source,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QuantumKey) Reset() {
	*x = QuantumKey{}
	mi := &file_crypto_crypto_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QuantumKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuantumKey) ProtoMessage() {}

func (x *QuantumKey) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuantumKey.ProtoReflect.Descriptor instead.
func (*QuantumKey) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{7}
}

func (x *QuantumKey) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *QuantumKey) GetAlgorithm() string {
	if x != nil {
		return x.Algorithm
	}
	return ""
}

func (x *QuantumKey) GetGeneratedAt() int64 {
	if x != nil {
		return x.GeneratedAt
	}
	return 0
}

func (x *QuantumKey) GetEntropySource() string {
	if x != nil {
		return x.EntropySource
	}
	return ""
}

type EncryptRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Plaintext     []byte                 `protobuf:"bytes,1,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Algorithm     string                 `protobuf:"bytes,3,opt,name=algorithm,proto3" json:"algorithm,omitempty"` // "otp", "aes-qrng"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EncryptRequest) Reset() {
	*x = EncryptRequest{}
	mi := &file_crypto_crypto_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptRequest) ProtoMessage() {}

func (x *EncryptRequest) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptRequest.ProtoReflect.Descriptor instead.
func (*EncryptRequest) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{8}
}

func (x *EncryptRequest) GetPlaintext() []byte {
	if x != nil {
		return x.Plaintext
	}
	return nil
}

func (x *EncryptRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *EncryptRequest) GetAlgorithm() string {
	if x != nil {
		return x.Algorithm
	}
	return ""
}

type EncryptedMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ciphertext    []byte                 `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	Nonce         []byte                 `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Algorithm     string                 `protobuf:"bytes,3,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EncryptedMessage) Reset() {
	*x = EncryptedMessage{}
	mi := &file_crypto_crypto_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptedMessage) ProtoMessage() {}

func (x *EncryptedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptedMessage.ProtoReflect.Descriptor instead.
func (*EncryptedMessage) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{9}
}

func (x *EncryptedMessage) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

func (x *EncryptedMessage) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *EncryptedMessage) GetAlgorithm() string {
	if x != nil {
		return x.Algorithm
	}
	return ""
}

type DecryptRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ciphertext    []byte                 `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Nonce         []byte                 `protobuf:"bytes,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Algorithm     string                 `protobuf:"bytes,4,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DecryptRequest) Reset() {
	*x = DecryptRequest{}
	mi := &file_crypto_crypto_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DecryptRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DecryptRequest) ProtoMessage() {}

func (x *DecryptRequest) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DecryptRequest.ProtoReflect.Descriptor instead.
func (*DecryptRequest) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{10}
}

func (x *DecryptRequest) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

func (x *DecryptRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *DecryptRequest) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *DecryptRequest) GetAlgorithm() string {
	if x != nil {
		return x.Algorithm
	}
	return ""
}

type DecryptedMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Plaintext     []byte                 `protobuf:"bytes,1,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
	Valid         bool                   `protobuf:"varint,2,opt,name=valid,proto3" json:"valid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DecryptedMessage) Reset() {
	*x = DecryptedMessage{}
	mi := &file_crypto_crypto_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DecryptedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DecryptedMessage) ProtoMessage() {}

func (x *DecryptedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DecryptedMessage.ProtoReflect.Descriptor instead.
func (*DecryptedMessage) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{11}
}

func (x *DecryptedMessage) GetPlaintext() []byte {
	if x != nil {
		return x.Plaintext
	}
	return nil
}

func (x *DecryptedMessage) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

type EavesdropRequest struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	SessionId            string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	AliceCheckBits       []int32                `protobuf:"varint,2,rep,packed,name=alice_check_bits,json=aliceCheckBits,proto3" json:"alice_check_bits,omitempty"`
	BobCheckBits         []int32                `protobuf:"varint,3,rep,packed,name=bob_check_bits,json=bobCheckBits,proto3" json:"bob_check_bits,omitempty"`
	EavesdropProbability float64                `protobuf:"fixed64,4,opt,name=eavesdrop_probability,json=eavesdropProbability,proto3" json:"eavesdrop_probability,omitempty"` // Probability that Eve measures a qubit (0.0 - 1.0)
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *EavesdropRequest) Reset() {
	*x = EavesdropRequest{}
	mi := &file_crypto_crypto_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EavesdropRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EavesdropRequest) ProtoMessage() {}

func (x *EavesdropRequest) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EavesdropRequest.ProtoReflect.Descriptor instead.
func (*EavesdropRequest) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{12}
}

func (x *EavesdropRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *EavesdropRequest) GetAliceCheckBits() []int32 {
	if x != nil {
		return x.AliceCheckBits
	}
	return nil
}

func (x *EavesdropRequest) GetBobCheckBits() []int32 {
	if x != nil {
		return x.BobCheckBits
	}
	return nil
}

func (x *EavesdropRequest) GetEavesdropProbability() float64 {
	if x != nil {
		return x.EavesdropProbability
	}
	return 0
}

type EavesdropResult struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	ErrorRate            float64                `protobuf:"fixed64,1,opt,name=error_rate,json=errorRate,proto3" json:"error_rate,omitempty"`
	EavesdropperDetected bool                   `protobuf:"varint,2,opt,name=eavesdropper_detected,json=eavesdropperDetected,proto3" json:"eavesdropper_detected,omitempty"`
	Recommendation       string                 `protobuf:"bytes,3,opt,name=recommendation,proto3" json:"recommendation,omitempty"` // "proceed", "abort", "retry"
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *EavesdropResult) Reset() {
	*x = EavesdropResult{}
	mi := &file_crypto_crypto_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EavesdropResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EavesdropResult) ProtoMessage() {}

func (x *EavesdropResult) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EavesdropResult.ProtoReflect.Descriptor instead.
func (*EavesdropResult) Descriptor() ([]byte, []int) {
	return file_crypto_crypto_proto_rawDescGZIP(), []int{13}
}

func (x *EavesdropResult) GetErrorRate() float64 {
	if x != nil {
		return x.ErrorRate
	}
	return 0
}

func (x *EavesdropResult) GetEavesdropperDetected() bool {
	if x != nil {
		return x.EavesdropperDetected
	}
	return false
}

func (x *EavesdropResult) GetRecommendation() string {
	if x != nil {
		return x.Recommendation
	}
	return ""
}

var File_crypto_crypto_proto protoreflect.FileDescriptor

const file_crypto_crypto_proto_rawDesc = "" +
	"\n" +
	"\x13crypto/crypto.proto\x12\x13qubit_engine.crypto\"\x81\x01\n" +
	"\x10BB84AliceRequest\x12\x19\n" +
	"\bnum_bits\x18\x01 \x01(\x05R\anumBits\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x123\n" +
	"\x15eavesdrop_probability\x18\x03 \x01(\x01R\x14eavesdropProbability\"\x9c\x01\n" +
	"\x0eBB84AliceState\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x12\n" +
	"\x04bits\x18\x02 \x03(\x05R\x04bits\x120\n" +
	"\x05bases\x18\x03 \x03(\x0e2\x1a.qubit_engine.crypto.BasisR\x05bases\x12%\n" +
	"\x0equantum_states\x18\x04 \x01(\fR\rquantumStates\"V\n" +
	"\x0eBB84BobRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12%\n" +
	"\x0equantum_states\x18\x02 \x01(\fR\rquantumStates\"\x83\x01\n" +
	"\fBB84BobState\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x120\n" +
	"\x05bases\x18\x02 \x03(\x0e2\x1a.qubit_engine.crypto.BasisR\x05bases\x12\"\n" +
	"\fmeasurements\x18\x03 \x03(\x05R\fmeasurements\"\xf1\x01\n" +
	"\x10ReconcileRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12;\n" +
	"\valice_bases\x18\x02 \x03(\x0e2\x1a.qubit_engine.crypto.BasisR\n" +
	"aliceBases\x127\n" +
	"\tbob_bases\x18\x03 \x03(\x0e2\x1a.qubit_engine.crypto.BasisR\bbobBases\x12\x1d\n" +
	"\n" +
	"alice_bits\x18\x04 \x03(\x05R\taliceBits\x12)\n" +
	"\x10bob_measurements\x18\x05 \x03(\x05R\x0fbobMeasurements\"\xc4\x01\n" +
	"\aBB84Key\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1d\n" +
	"\n" +
	"shared_key\x18\x02 \x01(\fR\tsharedKey\x12#\n" +
	"\roriginal_bits\x18\x03 \x01(\x05R\foriginalBits\x12\x1f\n" +
	"\vsifted_bits\x18\x04 \x01(\x05R\n" +
	"siftedBits\x12\x1d\n" +
	"\n" +
	"error_rate\x18\x05 \x01(\x01R\terrorRate\x12\x16\n" +
	"\x06secure\x18\x06 \x01(\bR\x06secure\"R\n" +
	"\n" +
	"KeyRequest\x12&\n" +
	"\x0fkey_length_bits\x18\x01 \x01(\x05R\rkeyLengthBits\x12\x1c\n" +
	"\talgorithm\x18\x02 \x01(\tR\talgorithm\"\x86\x01\n" +
	"\n" +
	"QuantumKey\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12\x1c\n" +
	"\talgorithm\x18\x02 \x01(\tR\talgorithm\x12!\n" +
	"\fgenerated_at\x18\x03 \x01(\x03R\vgeneratedAt\x12%\n" +
	"\x0eentropy_source\x18\x04 \x01(\tR\rentropySource\"^\n" +
	"\x0eEncryptRequest\x12\x1c\n" +
	"\tplaintext\x18\x01 \x01(\fR\tplaintext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x1c\n" +
	"\talgorithm\x18\x03 \x01(\tR\talgorithm\"f\n" +
	"\x10EncryptedMessage\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x01 \x01(\fR\n" +
	"ciphertext\x12\x14\n" +
	"\x05nonce\x18\x02 \x01(\fR\x05nonce\x12\x1c\n" +
	"\talgorithm\x18\x03 \x01(\tR\talgorithm\"v\n" +
	"\x0eDecryptRequest\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x01 \x01(\fR\n" +
	"ciphertext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x14\n" +
	"\x05nonce\x18\x03 \x01(\fR\x05nonce\x12\x1c\n" +
	"\talgorithm\x18\x04 \x01(\tR\talgorithm\"F\n" +
	"\x10DecryptedMessage\x12\x1c\n" +
	"\tplaintext\x18\x01 \x01(\fR\tplaintext\x12\x14\n" +
	"\x05valid\x18\x02 \x01(\bR\x05valid\"\xb6\x01\n" +
	"\x10EavesdropRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12(\n" +
	"\x10alice_check_bits\x18\x02 \x03(\x05R\x0ealiceCheckBits\x12$\n" +
	"\x0ebob_check_bits\x18\x03 \x03(\x05R\fbobCheckBits\x123\n" +
	"\x15eavesdrop_probability\x18\x04 \x01(\x01R\x14eavesdropProbability\"\x8d\x01\n" +
	"\x0fEavesdropResult\x12\x1d\n" +
	"\n" +
	"error_rate\x18\x01 \x01(\x01R\terrorRate\x123\n" +
	"\x15eavesdropper_detected\x18\x02 \x01(\bR\x14eavesdropperDetected\x12&\n" +
	"\x0erecommendation\x18\x03 \x01(\tR\x0erecommendation*2\n" +
	"\x05Basis\x12\x15\n" +
	"\x11BASIS_RECTILINEAR\x10\x00\x12\x12\n" +
	"\x0eBASIS_DIAGONAL\x10\x012\x93\x05\n" +
	"\rQuantumCrypto\x12\\\n" +
	"\x0eStartBB84Alice\x12%.qubit_engine.crypto.BB84AliceRequest\x1a#.qubit_engine.crypto.BB84AliceState\x12V\n" +
	"\fStartBB84Bob\x12#.qubit_engine.crypto.BB84BobRequest\x1a!.qubit_engine.crypto.BB84BobState\x12T\n" +
	"\rReconcileBB84\x12%.qubit_engine.crypto.ReconcileRequest\x1a\x1c.qubit_engine.crypto.BB84Key\x12V\n" +
	"\x12GenerateQuantumKey\x12\x1f.qubit_engine.crypto.KeyRequest\x1a\x1f.qubit_engine.crypto.QuantumKey\x12\\\n" +
	"\x0eQuantumEncrypt\x12#.qubit_engine.crypto.EncryptRequest\x1a%.qubit_engine.crypto.EncryptedMessage\x12\\\n" +
	"\x0eQuantumDecrypt\x12#.qubit_engine.crypto.DecryptRequest\x1a%.qubit_engine.crypto.DecryptedMessage\x12b\n" +
	"\x13DetectEavesdropping\x12%.qubit_engine.crypto.EavesdropRequest\x1a$.qubit_engine.crypto.EavesdropResultB@Z>github.com/perclft/QubitEngine/modules/crypto/generated/cryptob\x06proto3"

var (
	file_crypto_crypto_proto_rawDescOnce sync.Once
	file_crypto_crypto_proto_rawDescData []byte
)

func file_crypto_crypto_proto_rawDescGZIP() []byte {
	file_crypto_crypto_proto_rawDescOnce.Do(func() {
		file_crypto_crypto_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_crypto_crypto_proto_rawDesc), len(file_crypto_crypto_proto_rawDesc)))
	})
	return file_crypto_crypto_proto_rawDescData
}

var file_crypto_crypto_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_crypto_crypto_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_crypto_crypto_proto_goTypes = []any{
	(Basis)(0),               // 0: qubit_engine.crypto.Basis
	(*BB84AliceRequest)(nil), // 1: qubit_engine.crypto.BB84AliceRequest
	(*BB84AliceState)(nil),   // 2: qubit_engine.crypto.BB84AliceState
	(*BB84BobRequest)(nil),   // 3: qubit_engine.crypto.BB84BobRequest
	(*BB84BobState)(nil),     // 4: qubit_engine.crypto.BB84BobState
	(*ReconcileRequest)(nil), // 5: qubit_engine.crypto.ReconcileRequest
	(*BB84Key)(nil),          // 6: qubit_engine.crypto.BB84Key
	(*KeyRequest)(nil),       // 7: qubit_engine.crypto.KeyRequest
	(*QuantumKey)(nil),       // 8: qubit_engine.crypto.QuantumKey
	(*EncryptRequest)(nil),   // 9: qubit_engine.crypto.EncryptRequest
	(*EncryptedMessage)(nil), // 10: qubit_engine.crypto.EncryptedMessage
	(*DecryptRequest)(nil),   // 11: qubit_engine.crypto.DecryptRequest
	(*DecryptedMessage)(nil), // 12: qubit_engine.crypto.DecryptedMessage
	(*EavesdropRequest)(nil), // 13: qubit_engine.crypto.EavesdropRequest
	(*EavesdropResult)(nil),  // 14: qubit_engine.crypto.EavesdropResult
}
var file_crypto_crypto_proto_depIdxs = []int32{
	0,  // 0: qubit_engine.crypto.BB84AliceState.bases:type_name -> qubit_engine.crypto.Basis
	0,  // 1: qubit_engine.crypto.BB84BobState.bases:type_name -> qubit_engine.crypto.Basis
	0,  // 2: qubit_engine.crypto.ReconcileRequest.alice_bases:type_name -> qubit_engine.crypto.Basis
	0,  // 3: qubit_engine.crypto.ReconcileRequest.bob_bases:type_name -> qubit_engine.crypto.Basis
	1,  // 4: qubit_engine.crypto.QuantumCrypto.StartBB84Alice:input_type -> qubit_engine.crypto.BB84AliceRequest
	3,  // 5: qubit_engine.crypto.QuantumCrypto.StartBB84Bob:input_type -> qubit_engine.crypto.BB84BobRequest
	5,  // 6: qubit_engine.crypto.QuantumCrypto.ReconcileBB84:input_type -> qubit_engine.crypto.ReconcileRequest
	7,  // 7: qubit_engine.crypto.QuantumCrypto.GenerateQuantumKey:input_type -> qubit_engine.crypto.KeyRequest
	9,  // 8: qubit_engine.crypto.QuantumCrypto.QuantumEncrypt:input_type -> qubit_engine.crypto.EncryptRequest
	11, // 9: qubit_engine.crypto.QuantumCrypto.QuantumDecrypt:input_type -> qubit_engine.crypto.DecryptRequest
	13, // 10: qubit_engine.crypto.QuantumCrypto.DetectEavesdropping:input_type -> qubit_engine.crypto.EavesdropRequest
	2,  // 11: qubit_engine.crypto.QuantumCrypto.StartBB84Alice:output_type -> qubit_engine.crypto.BB84AliceState
	4,  // 12: qubit_engine.crypto.QuantumCrypto.StartBB84Bob:output_type -> qubit_engine.crypto.BB84BobState
	6,  // 13: qubit_engine.crypto.QuantumCrypto.ReconcileBB84:output_type -> qubit_engine.crypto.BB84Key
	8,  // 14: qubit_engine.crypto.QuantumCrypto.GenerateQuantumKey:output_type -> qubit_engine.crypto.QuantumKey
	10, // 15: qubit_engine.crypto.QuantumCrypto.QuantumEncrypt:output_type -> qubit_engine.crypto.EncryptedMessage
	12, // 16: qubit_engine.crypto.QuantumCrypto.QuantumDecrypt:output_type -> qubit_engine.crypto.DecryptedMessage
	14, // 17: qubit_engine.crypto.QuantumCrypto.DetectEavesdropping:output_type -> qubit_engine.crypto.EavesdropResult
	11, // [11:18] is the sub-list for method output_type
	4,  // [4:11] is the sub-list for method input_type
	4,  // [4:4] is the sub-list for extension type_name
	4,  // [4:4] is the sub-list for extension extendee
	0,  // [0:4] is the sub-list for field type_name
}

func init() { file_crypto_crypto_proto_init() }
func file_crypto_crypto_proto_init() {
	if File_crypto_crypto_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_crypto_crypto_proto_rawDesc), len(file_crypto_crypto_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_crypto_crypto_proto_goTypes,
		DependencyIndexes: file_crypto_crypto_proto_depIdxs,
		EnumInfos:         file_crypto_crypto_proto_enumTypes,
		MessageInfos:      file_crypto_crypto_proto_msgTypes,
	}.Build()
	File_crypto_crypto_proto = out.File
	file_crypto_crypto_proto_goTypes = nil
	file_crypto_crypto_proto_depIdxs = nil
}
